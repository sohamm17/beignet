From b4dc8376a24cc4e0bfacdb57ca3a1da87c8c90f4 Mon Sep 17 00:00:00 2001
From: Zhigang Gong <zhigang.gong@linux.intel.com>
Date: Mon, 13 May 2013 11:32:20 +0800
Subject: [PATCH 11/15] utests: Add one test cases for sampler support.
To: beignet@lists.freedesktop.org

This new case tests define sampler in kernel side and in the
kernel argument.

Signed-off-by: Zhigang Gong <zhigang.gong@linux.intel.com>
---
 kernels/test_copy_image1.cl     |   33 +++++++++++++++++
 utests/CMakeLists.txt           |    1 +
 utests/compiler_copy_image1.cpp |   77 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 111 insertions(+)
 create mode 100644 kernels/test_copy_image1.cl
 create mode 100644 utests/compiler_copy_image1.cpp

Index: beignet-0.1+git20130514+19e9c58/kernels/test_copy_image1.cl
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ beignet-0.1+git20130514+19e9c58/kernels/test_copy_image1.cl	2013-05-14 20:09:21.802021741 +0200
@@ -0,0 +1,33 @@
+#define S(A,B,C) CLK_NORMALIZED_COORDS_##A | CLK_ADDRESS_##B | CLK_FILTER_##C
+
+#define COPY_IMAGE(_dst, _sampler, scoord, dcoord) \
+  color = read_imagei(src, _sampler, scoord);\
+  write_imagei(_dst, dcoord, color)
+
+__kernel void
+test_copy_image1(__read_only image2d_t src,
+                 __write_only image2d_t dst0,
+                 sampler_t sampler0,
+                 __write_only image2d_t dst1,
+                 __write_only image2d_t dst2,
+                 __write_only image2d_t dst3,
+                 __write_only image2d_t dst4,
+                 float w_inv, float h_inv)
+{
+  const sampler_t sampler1 = S(FALSE, REPEAT, NEAREST);
+  const sampler_t sampler2 = S(FALSE, CLAMP, NEAREST);
+  const sampler_t sampler3 = S(FALSE, MIRRORED_REPEAT, NEAREST);
+  const sampler_t sampler4 = S(TRUE, REPEAT, NEAREST);
+  int2 coord;
+  float2 fcoord;
+  int4 color;
+  coord.x = (int)get_global_id(0);
+  coord.y = (int)get_global_id(1);
+  fcoord.x = coord.x * w_inv;
+  fcoord.y = coord.y * h_inv;
+  COPY_IMAGE(dst0, sampler0, coord, coord);
+  COPY_IMAGE(dst1, sampler1, coord, coord);
+  COPY_IMAGE(dst2, sampler2, coord, coord);
+  COPY_IMAGE(dst3, sampler3, coord, coord);
+  COPY_IMAGE(dst4, sampler4, fcoord, coord);
+}
Index: beignet-0.1+git20130514+19e9c58/utests/CMakeLists.txt
===================================================================
--- beignet-0.1+git20130514+19e9c58.orig/utests/CMakeLists.txt	2013-05-08 11:55:52.000000000 +0200
+++ beignet-0.1+git20130514+19e9c58/utests/CMakeLists.txt	2013-05-14 20:09:21.802021741 +0200
@@ -74,6 +74,7 @@
   compiler_local_memory_barrier_wg64.cpp
   compiler_movforphi_undef.cpp
   compiler_volatile.cpp
+  compiler_copy_image1.cpp
   runtime_createcontext.cpp
   utest_assert.cpp
   utest.cpp
Index: beignet-0.1+git20130514+19e9c58/utests/compiler_copy_image1.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ beignet-0.1+git20130514+19e9c58/utests/compiler_copy_image1.cpp	2013-05-14 20:09:21.802021741 +0200
@@ -0,0 +1,77 @@
+#include "utest_helper.hpp"
+
+static void compiler_copy_image1(void)
+{
+  const size_t w = 512;
+  const size_t h = 512;
+  cl_image_format format;
+  cl_image_desc desc;
+  cl_sampler sampler;
+
+  // Setup kernel and images
+  OCL_CREATE_KERNEL("test_copy_image1");
+  buf_data[0] = (uint32_t*) malloc(sizeof(uint32_t) * w * h);
+  for (uint32_t j = 0; j < h; ++j)
+    for (uint32_t i = 0; i < w; i++)
+      ((uint32_t*)buf_data[0])[j * w + i] = j * w + i;
+
+  format.image_channel_order = CL_RGBA;
+  format.image_channel_data_type = CL_UNSIGNED_INT8;
+  desc.image_type = CL_MEM_OBJECT_IMAGE2D;
+  desc.image_width = w;
+  desc.image_height = h;
+  desc.image_row_pitch = w * sizeof(uint32_t);
+  OCL_CREATE_IMAGE(buf[0], CL_MEM_COPY_HOST_PTR, &format, &desc, buf_data[0]);
+  OCL_CREATE_SAMPLER(sampler, CL_ADDRESS_REPEAT, CL_FILTER_NEAREST);
+
+  desc.image_row_pitch = 0;
+  OCL_CREATE_IMAGE(buf[1], 0, &format, &desc, NULL);
+  OCL_CREATE_IMAGE(buf[2], 0, &format, &desc, NULL);
+  OCL_CREATE_IMAGE(buf[3], 0, &format, &desc, NULL);
+  OCL_CREATE_IMAGE(buf[4], 0, &format, &desc, NULL);
+  OCL_CREATE_IMAGE(buf[5], 0, &format, &desc, NULL);
+  free(buf_data[0]);
+  buf_data[0] = NULL;
+
+  // Run the kernel
+  OCL_SET_ARG(0, sizeof(cl_mem), &buf[0]);
+  OCL_SET_ARG(1, sizeof(cl_mem), &buf[1]);
+  OCL_SET_ARG(2, sizeof(sampler), &sampler);
+  OCL_SET_ARG(3, sizeof(cl_mem), &buf[2]);
+  OCL_SET_ARG(4, sizeof(cl_mem), &buf[3]);
+  OCL_SET_ARG(5, sizeof(cl_mem), &buf[4]);
+  OCL_SET_ARG(6, sizeof(cl_mem), &buf[5]);
+  float w_inv = 1.0/w;
+  float h_inv = 1.0/h;
+  OCL_SET_ARG(7, sizeof(float), &w_inv);
+  OCL_SET_ARG(8, sizeof(float), &h_inv);
+
+  globals[0] = w;
+  globals[1] = h;
+  locals[0] = 16;
+  locals[1] = 16;
+  OCL_NDRANGE(2);
+
+  // Check result
+  OCL_MAP_BUFFER(0);
+  OCL_MAP_BUFFER(1);
+  OCL_MAP_BUFFER(2);
+  OCL_MAP_BUFFER(3);
+  OCL_MAP_BUFFER(4);
+  OCL_MAP_BUFFER(5);
+
+  for(uint32_t k = 0; k < 5; k++)
+  {
+    for (uint32_t j = 0; j < h; ++j)
+      for (uint32_t i = 0; i < w; i++)
+        OCL_ASSERT(((uint32_t*)buf_data[0])[j * w + i] == ((uint32_t*)buf_data[1 + k])[j * w + i]);
+  }
+  OCL_UNMAP_BUFFER(0);
+  OCL_UNMAP_BUFFER(1);
+  OCL_UNMAP_BUFFER(2);
+  OCL_UNMAP_BUFFER(3);
+  OCL_UNMAP_BUFFER(4);
+  OCL_UNMAP_BUFFER(5);
+}
+
+MAKE_UTEST_FROM_FUNCTION(compiler_copy_image1);
