From 4c2f4a53d5c9a9eca0b8d55586fa1d8f070faddf Mon Sep 17 00:00:00 2001
From: Zhigang Gong <zhigang.gong@linux.intel.com>
Date: Wed, 19 Jun 2013 18:36:30 +0800
Subject: [PATCH 12/12] GBE: Fixed one bug in scalarize pass
To: beignet@lists.freedesktop.org

I met segfault at void Scalarize::dce() randomly when I integrate
a openCL kernel to the chromium's GPU process. After discuss with
Yang Rong, I found one bug in this function. As it use two loops
to erase the dead instructions, but it doesn't set the pointer to
NULL at the first loop when it already erased the instruction. Thus
at the second loop, when it call (*i)->getParent, the (*i) may
already be deleted then it may refer a freed region and may cause
segfault.

Signed-off-by: Zhigang Gong <zhigang.gong@linux.intel.com>
---
 backend/src/llvm/llvm_scalarize.cpp |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

Index: beignet-0.1+git20130619+42967d2/backend/src/llvm/llvm_scalarize.cpp
===================================================================
--- beignet-0.1+git20130619+42967d2.orig/backend/src/llvm/llvm_scalarize.cpp	2013-06-19 21:03:23.570670069 +0200
+++ beignet-0.1+git20130619+42967d2/backend/src/llvm/llvm_scalarize.cpp	2013-06-19 21:04:53.078666079 +0200
@@ -825,11 +825,13 @@
     //two passes delete for some phinode
     for (std::vector<Instruction*>::reverse_iterator i = deadList.rbegin(), e = deadList.rend(); i != e; ++i) {
       (*i)->dropAllReferences();
-      if((*i)->use_empty())
+      if((*i)->use_empty()) {
         (*i)->eraseFromParent();
+        (*i) = NULL;
+      }
     }
     for (std::vector<Instruction*>::reverse_iterator i = deadList.rbegin(), e = deadList.rend(); i != e; ++i) {
-      if((*i)->getParent())
+      if((*i) && (*i)->getParent())
         (*i)->eraseFromParent();
     }
     deadList.clear();
