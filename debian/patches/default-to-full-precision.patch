Description: Default to standard-compliant precision

The OpenCL specification requires that any fast-but-imprecise mode
be off by default: being too slow is usually more obvious than
being too inaccurate.

Author: Rebecca N. Palmer <rebecca_palmer@zoho.com>

--- beignet-1.0.2.orig/backend/src/backend/program.cpp
+++ beignet-1.0.2/backend/src/backend/program.cpp
@@ -113,7 +113,7 @@ namespace gbe {
 
 #ifdef GBE_COMPILER_AVAILABLE
   BVAR(OCL_OUTPUT_GEN_IR, false);
-  BVAR(OCL_STRICT_CONFORMANCE, false);
+  BVAR(OCL_STRICT_CONFORMANCE, true);
 
   bool Program::buildFromLLVMFile(const char *fileName, const void* module, std::string &error, int optLevel) {
     ir::Unit *unit = new ir::Unit();
--- beignet-1.0.2.orig/docs/Beignet.mdwn
+++ beignet-1.0.2/docs/Beignet.mdwn
@@ -169,8 +169,10 @@ Known Issues
 * Precision issue.
   Currently Gen does not provide native support of high precision math functions
   required by OpenCL. We provide a software version to achieve high precision,
-  which you can turn on through `export OCL_STRICT_CONFORMANCE=1`.
-  But be careful, this would make your CL kernel run a little longer.
+  controlled by the OCL_STRICT_CONFORMANCE environment variable. Default is
+  1 (high-precision) in Debian beignet but 0 (high-speed) in upstream beignet.
+
+  The native_* functions are always high-speed/low-precision.
 
 * cl\_khr\_gl\_sharing.
   This extension highly depends on mesa support. It seems that mesa would not provide
--- beignet-1.0.2.orig/docs/Beignet/Backend.mdwn
+++ beignet-1.0.2/docs/Beignet/Backend.mdwn
@@ -37,9 +37,8 @@ Environment variables are used all over
   precision math instructions compliant with OpenCL Spec. So we provide a
   software version to meet the high precision requirement. Obviously the
   software version's performance is not as good as native version supported by
-  GEN hardware. What's more, most graphics application don't need this high
-  precision, so we choose 0 as the default value. So OpenCL apps do not suffer
-  the performance penalty for using high precision math functions.
+  GEN hardware.  Default is 1 (high-precision) in Debian beignet but
+  0 (high-speed) in upstream beignet.
 
 - `OCL_SIMD_WIDTH` `(8 or 16)`. Select the number of lanes per hardware thread,
   Normally, you don't need to set it, we will select suitable simd width for
--- beignet-1.0.2.orig/utests/builtin_pow.cpp
+++ beignet-1.0.2/utests/builtin_pow.cpp
@@ -40,7 +40,7 @@ static void builtin_pow(void)
 
   const char* env_strict = getenv("OCL_STRICT_CONFORMANCE");
   float ULPSIZE_FACTOR = 16.0;
-  if (env_strict == NULL || strcmp(env_strict, "0") == 0)
+  if (env_strict != NULL && strcmp(env_strict, "0") == 0)
     ULPSIZE_FACTOR = 10000.;
 
   OCL_CREATE_KERNEL("builtin_pow");
--- beignet-1.0.2.orig/utests/builtin_tgamma.cpp
+++ beignet-1.0.2/utests/builtin_tgamma.cpp
@@ -17,7 +17,7 @@ void builtin_tgamma(void)
   locals[0] = 16;
   const char* env_strict = getenv("OCL_STRICT_CONFORMANCE");
   float ULPSIZE_FACTOR = 16.0;
-  if (env_strict == NULL || strcmp(env_strict, "0") == 0)
+  if (env_strict != NULL && strcmp(env_strict, "0") == 0)
     ULPSIZE_FACTOR = 10000.;
 
   for (int j = 0; j < 1024; j ++) {
--- beignet-1.0.2.orig/utests/utest_generator.py
+++ beignet-1.0.2/utests/utest_generator.py
@@ -109,7 +109,7 @@ def udebug(ulpSize,returnType,function):
 
     const char* env_strict = getenv("OCL_STRICT_CONFORMANCE");
 
-    if (env_strict == NULL || strcmp(env_strict, "0") == 0)
+    if (env_strict != NULL && strcmp(env_strict, "0") == 0)
       ULPSIZE_FACTOR = 1000;
     else
       ULPSIZE_FACTOR = %s;
