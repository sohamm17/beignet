Description: Don't try to use sysinfo or CLOCK_MONOTONIC_RAW on non-Linux

Fixes two FTBFS on kfreebsd due to use of Linux-specific features:
https://buildd.debian.org/status/fetch.php?pkg=beignet&arch=kfreebsd-amd64&ver=1.0.1-3&stamp=1425101150
https://buildd.debian.org/status/fetch.php?pkg=beignet&arch=kfreebsd-amd64&ver=1.1.1-1&stamp=1445338350

Origin: https://github.com/freebsd/freebsd-ports-graphics/blob/opencl/lang/beignet/files/patch-src_cl__device__id.c https://github.com/freebsd/freebsd-ports-graphics/blob/master/lang/beignet/files/patch-src_cl__event.c
Author: Koop Mast, Rebecca Palmer

--- a/src/cl_device_id.c
+++ b/src/cl_device_id.c
@@ -34,7 +34,12 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#if defined(linux) || defined(__linux__) || defined(__LINUX__)
 #include <sys/sysinfo.h>
+#else
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#endif
 
 #ifndef CL_VERSION_1_2
 #define CL_DEVICE_BUILT_IN_KERNELS 0x103F
@@ -546,6 +551,7 @@ skl_gt4_break:
   /* Apply any driver-dependent updates to the device info */
   cl_driver_update_device_info(ret);
 
+#if defined(linux) || defined(__linux__) || defined(__LINUX__)
   struct sysinfo info;
   if (sysinfo(&info) == 0) {
     uint64_t two_gb = 2 * 1024 * 1024 * 1024ul; 
@@ -554,6 +559,22 @@ skl_gt4_break:
                             two_gb : info.totalram;
     ret->max_mem_alloc_size = ret->global_mem_size / 2;
   }
+#else
+  int mib[2];
+
+  mib[0] = CTL_HW;
+  mib[1] = HW_USERMEM;
+
+  uint64_t totalram;
+  size_t len;
+  len = sizeof(totalram);
+  sysctl(mib, 2, &totalram, &len, NULL, 0);
+
+  uint64_t two_gb = 2 * 1024 * 1024 * 1024ul;
+  ret->global_mem_size = (totalram > two_gb) ?
+                            two_gb : totalram;
+  ret->max_mem_alloc_size = ret->global_mem_size / 2;
+#endif
 
   return ret;
 }
--- a/src/cl_event.c
+++ b/src/cl_event.c
@@ -27,6 +27,7 @@
 
 #include <assert.h>
 #include <stdio.h>
+#include <time.h>
 
 inline cl_bool
 cl_event_is_gpu_command_type(cl_command_type type)
@@ -617,7 +618,11 @@ cl_ulong cl_event_get_cpu_timestamp(cl_u
 {
   struct timespec ts;
 
- if(clock_gettime(CLOCK_MONOTONIC_RAW,&ts) != 0){
+#if defined(linux) || defined(__linux__) || defined(__LINUX__)
+ if(clock_gettime(CLOCK_MONOTONIC_RAW,&ts) != 0){
+#else
+ if(clock_gettime(CLOCK_MONOTONIC,&ts) != 0){
+#endif
   printf("CPU Timmer error\n");
   return CL_FALSE;
   }

