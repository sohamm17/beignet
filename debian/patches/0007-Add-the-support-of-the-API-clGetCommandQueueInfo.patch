From 1e1556a65ff1779dca6a5b30c204985ad14f0e4f Mon Sep 17 00:00:00 2001
From: Junyan He <junyan.he@linux.intel.com>
Date: Tue, 25 Jun 2013 18:15:25 +0800
Subject: [PATCH 7/8] Add the support of the API: clGetCommandQueueInfo
To: beignet@lists.freedesktop.org

Though we support get the CL_QUEUE_PROPERTIES,
but because the CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE
and CL_QUEUE_PROFILING_ENABLE will never be set when
create the queue, it just return a all 0 bitfield now.

Signed-off-by: Junyan He <junyan.he@linux.intel.com>
---
 src/cl_api.c           |   63 ++++++++++++++++++++++++++++--------------------
 src/cl_command_queue.h |   15 ++++++------
 src/cl_context.c       |    1 +
 3 files changed, 46 insertions(+), 33 deletions(-)

diff --git a/src/cl_api.c b/src/cl_api.c
index ebca294..bb09c07 100644
--- a/src/cl_api.c
+++ b/src/cl_api.c
@@ -46,6 +46,19 @@
 typedef intptr_t cl_device_partition_property;
 #endif
 
+#define FILL_GETINFO_RET(TYPE, ELT, VAL, RET) \
+	do { \
+	  if (param_value && param_value_size < sizeof(TYPE)*ELT) \
+	      return CL_INVALID_VALUE;  \
+	  if (param_value) { \
+	      memcpy(param_value, (VAL), sizeof(TYPE)*ELT); \
+	  } \
+          \
+	  if (param_value_size_ret) \
+	      *param_value_size_ret = sizeof(TYPE)*ELT; \
+	  return RET; \
+	} while(0)
+
 static cl_int
 cl_check_device_type(cl_device_type device_type)
 {
@@ -341,7 +354,20 @@ clGetCommandQueueInfo(cl_command_queue       command_queue,
 {
   cl_int err = CL_SUCCESS;
   CHECK_QUEUE (command_queue);
-  NOT_IMPLEMENTED;
+
+  if (param_name == CL_QUEUE_CONTEXT) {
+    FILL_GETINFO_RET (cl_context, 1, &command_queue->ctx, CL_SUCCESS);
+  } else if (param_name == CL_QUEUE_DEVICE) {
+    FILL_GETINFO_RET (cl_device_id, 1, &command_queue->ctx->device, CL_SUCCESS);
+  } else if (param_name == CL_QUEUE_REFERENCE_COUNT) {
+    cl_uint ref = command_queue->ref_n;
+    FILL_GETINFO_RET (cl_uint, 1, &ref, CL_SUCCESS);
+  } else if (param_name == CL_QUEUE_PROPERTIES) {
+    FILL_GETINFO_RET (cl_command_queue_properties, 1, &command_queue->props, CL_SUCCESS);
+  } else {
+    return CL_INVALID_VALUE;
+  }
+
 error:
   return err;
 }
@@ -734,19 +760,6 @@ clUnloadCompiler(void)
   return 0;
 }
 
-#define FILL_AND_RET(TYPE, ELT, VAL, RET) \
-	do { \
-	  if (param_value && param_value_size < sizeof(TYPE)*ELT) \
-	      return CL_INVALID_VALUE;  \
-	  if (param_value) { \
-	      memcpy(param_value, (VAL), sizeof(TYPE)*ELT); \
-	  } \
-          \
-	  if (param_value_size_ret) \
-	      *param_value_size_ret = sizeof(TYPE)*ELT; \
-	  return RET; \
-	} while(0)
-
 cl_int
 clGetProgramInfo(cl_program       program,
                  cl_program_info  param_name,
@@ -761,24 +774,24 @@ clGetProgramInfo(cl_program       program,
 
   if (param_name == CL_PROGRAM_REFERENCE_COUNT) {
     cl_uint ref = program->ref_n;
-    FILL_AND_RET (cl_uint, 1, (&ref), CL_SUCCESS);
+    FILL_GETINFO_RET (cl_uint, 1, (&ref), CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_CONTEXT) {
     cl_context context = program->ctx;
-    FILL_AND_RET (cl_context, 1, &context, CL_SUCCESS);
+    FILL_GETINFO_RET (cl_context, 1, &context, CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_NUM_DEVICES) {
     cl_uint num_dev = 1; // Just 1 dev now.
-    FILL_AND_RET (cl_uint, 1, &num_dev, CL_SUCCESS);
+    FILL_GETINFO_RET (cl_uint, 1, &num_dev, CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_DEVICES) {
     cl_device_id dev_id = program->ctx->device;
-    FILL_AND_RET (cl_device_id, 1, &dev_id, CL_SUCCESS);
+    FILL_GETINFO_RET (cl_device_id, 1, &dev_id, CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_SOURCE) {
 
     if (!program->source)
-      FILL_AND_RET (char, 1, &ret_str, CL_SUCCESS);
-    FILL_AND_RET (char, (strlen(program->source) + 1),
+      FILL_GETINFO_RET (char, 1, &ret_str, CL_SUCCESS);
+    FILL_GETINFO_RET (char, (strlen(program->source) + 1),
                    program->source, CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_BINARY_SIZES) {
-    FILL_AND_RET (size_t, 1, (&program->bin_sz), CL_SUCCESS);
+    FILL_GETINFO_RET (size_t, 1, (&program->bin_sz), CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_BINARIES) {
     if (!param_value)
       return CL_SUCCESS;
@@ -825,15 +838,15 @@ clGetProgramBuildInfo(cl_program             program,
       status = CL_BUILD_ERROR;
     // TODO: Support CL_BUILD_IN_PROGRESS ?
 
-    FILL_AND_RET (cl_build_status, 1, &status, CL_SUCCESS);
+    FILL_GETINFO_RET (cl_build_status, 1, &status, CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_BUILD_OPTIONS) {
     if (program->is_built && program->build_opts)
       ret_str = program->build_opts;
 
-    FILL_AND_RET (char, (strlen(ret_str)+1), ret_str, CL_SUCCESS);
+    FILL_GETINFO_RET (char, (strlen(ret_str)+1), ret_str, CL_SUCCESS);
   } else if (param_name == CL_PROGRAM_BUILD_LOG) {
     // TODO: need to add logs in backend when compiling.
-    FILL_AND_RET (char, (strlen(ret_str)+1), ret_str, CL_SUCCESS);
+    FILL_GETINFO_RET (char, (strlen(ret_str)+1), ret_str, CL_SUCCESS);
   } else {
     return CL_INVALID_VALUE;
   }
@@ -842,8 +855,6 @@ error:
     return err;
 }
 
-#undef FILL_AND_RET
-
 cl_kernel
 clCreateKernel(cl_program   program,
                const char * kernel_name,
diff --git a/src/cl_command_queue.h b/src/cl_command_queue.h
index 0e04ff3..4f6f987 100644
--- a/src/cl_command_queue.h
+++ b/src/cl_command_queue.h
@@ -30,13 +30,14 @@ struct intel_gpgpu;
 /* Basically, this is a (kind-of) batch buffer */
 struct _cl_command_queue {
   DEFINE_ICD(dispatch)
-  uint64_t magic;              /* To identify it as a command queue */
-  volatile int ref_n;          /* We reference count this object */
-  cl_context ctx;              /* Its parent context */
-  cl_command_queue prev, next; /* We chain the command queues together */
-  cl_gpgpu gpgpu;              /* Setup all GEN commands */
-  cl_mem perf;                 /* Where to put the perf counters */
-  cl_mem fulsim_out;           /* Fulsim will output this buffer */
+  uint64_t magic;                      /* To identify it as a command queue */
+  volatile int ref_n;                  /* We reference count this object */
+  cl_context ctx;                      /* Its parent context */
+  cl_command_queue_properties  props;  /* Queue properties */
+  cl_command_queue prev, next;         /* We chain the command queues together */
+  cl_gpgpu gpgpu;                      /* Setup all GEN commands */
+  cl_mem perf;                         /* Where to put the perf counters */
+  cl_mem fulsim_out;                   /* Fulsim will output this buffer */
 };
 
 /* Allocate and initialize a new command queue. Also insert it in the list of
diff --git a/src/cl_context.c b/src/cl_context.c
index fa4c7e0..0331151 100644
--- a/src/cl_context.c
+++ b/src/cl_context.c
@@ -196,6 +196,7 @@ cl_context_create_queue(cl_context ctx,
 
   /* We create the command queue and store it in the context list of queues */
   TRY_ALLOC (queue, cl_command_queue_new(ctx));
+  queue->props = properties;
 
 exit:
   if (errcode_ret)
-- 
1.7.10.4

